# 53. 最大子序和

> https://leetcode-cn.com/problems/maximum-subarray/

## 1. 问题描述

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1
示例 3：

输入：nums = [0]
输出：0
示例 4：

输入：nums = [-1]
输出：-1
示例 5：

输入：nums = [-100000]
输出：-100000
 

提示：

1 <= nums.length <= 3 * 104
-105 <= nums[i] <= 105


## 2. 思路

- 动规

用dp[i]表示以i为结尾的nums[0:i]的最大连续子序列和。那么有
$$
\begin{aligned}
dp[i] &= \max \{ dp[i-1] + nums[i], nums[i] \} \\
result &= \max_i dp[i]
\end{aligned}
$$

注意因为是连续子序列，所以当dp[i-1] + nums[i]更小的时候，重新从nums[i]开始累积

```cpp
class Solution {
public:
    void dp(vector<int>& nums, int &result){
        int len = nums.size();
        int dp = nums[0];
        for(int i = 1; i < len; ++i){
            dp = max(dp + nums[i], nums[i]);
            result = max(result, dp);
        }
    }
    int maxSubArray(vector<int>& nums) {
        int result = nums[0];
        dp(nums, result);
        return result;
    }
};
```

- 使用数组前缀和

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int part_sum = nums[0], min_part_sum = 0;
        int res = nums[0];
        for(int i = 1, len = nums.size(); i < len; ++i){
            // 记录 i 之前中最小的前缀和
            min_part_sum = min(min_part_sum, part_sum);
            part_sum = part_sum + nums[i];
            // 以 i 结尾的子序列中，最大的连续和为 part_sum - min_part_sum
            res = max(res, part_sum - min_part_sum);
        }
        return res;
    }
};
```